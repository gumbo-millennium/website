<?php

declare(strict_types=1);

namespace App\Models\Orders;

use App\Casts\MoneyCast;
use App\Models\Shop\ProductVariant;
use App\Models\Ticket;
use App\Models\User;
use Brick\Money\Money;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Date;
use Illuminate\Support\Str;
use RuntimeException;

/**
 * An order, can be a mix of payments for activities and shop orders.
 *
 * @property int $id
 * @property string $number
 * @property null|int $user_id
 * @property string $status
 * @property null|\Illuminate\Support\Carbon $created_at
 * @property null|\Illuminate\Support\Carbon $updated_at
 * @property null|string $deleted_at
 * @property null|\Illuminate\Support\Carbon $confirmed_at
 * @property null|\Illuminate\Support\Carbon $shipped_at
 * @property null|\Illuminate\Support\Carbon $expires_at
 * @property string $name
 * @property string $email
 * @property null|\Brick\Money\Money $amount
 * @property null|\Brick\Money\Money $fee
 * @property null|\Brick\Money\Money $total_amount
 * @property string $description
 * @property-read \Illuminate\Database\Eloquent\Collection<int, ProductVariant> $productVariants
 * @property-read \Illuminate\Database\Eloquent\Collection<int, Ticket> $tickets
 * @property-read null|User $user
 * @method static \Database\Factories\Orders\OrderFactory factory($count = null, $state = [])
 * @method static \Illuminate\Database\Eloquent\Builder|Order newModelQuery()
 * @method static \Illuminate\Database\Eloquent\Builder|Order newQuery()
 * @method static \Illuminate\Database\Eloquent\Builder|Order query()
 * @mixin \Eloquent
 */
class Order extends Model
{
    use HasFactory;

    public const  ORDER_NUMBER_LENGTH = 8;

    public const ORDER_CREATION_ATTEMPTS = 10;

    protected $casts = [
        'confirmed_at' => 'datetime',
        'shipped_at' => 'datetime',
        'expires_at' => 'datetime',

        'amount' => MoneyCast::class,
        'fee' => MoneyCast::class,
        'total_amount' => MoneyCast::class,
    ];

    /**
     * Register some callbacks to ensure only valid objects are created.
     */
    protected static function booted(): void
    {
        parent::booted(); // TODO: Change the autogenerated stub

        static::creating(function (self $order) {
            $order->number = self::determineOrderNumber();
            $order->expires_at ??= Date::now()->addHours(24);
            $order->description ??= "Order {$order->number} for {$order->name}";
        });

        static::saving(function (self $order) {
            if ($order->confirmed_at !== null) {
                $order->expires_at = null;
            }
        });
    }

    /**
     * Determines a random order reference number.
     */
    private static function determineOrderNumber(): string
    {
        $orderPrefix = Date::now()->format('ym');
        $orderNumberOptions = Collection::times(
            self::ORDER_CREATION_ATTEMPTS,
            fn () => sprintf('%s.%s', $orderPrefix, Str::upper(Str::random(self::ORDER_NUMBER_LENGTH))),
        );

        $existingOrders = self::query()
            ->whereIn('number', $orderNumberOptions)
            ->pluck('number');

        $pickedOrder = $orderNumberOptions->diff($existingOrders)->first();
        if (! $pickedOrder) {
            throw new RuntimeException('Could not determine a unique order number.');
        }

        return $pickedOrder;
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function tickets(): BelongsToMany
    {
        return $this->belongsToMany(Ticket::class)
            ->using(OrderTicket::class);
    }

    public function productVariants(): BelongsToMany
    {
        return $this->belongsToMany(ProductVariant::class, 'order_products')
            ->using(OrderProduct::class);
    }

    /**
     * Calculate the total amount based on the amount and fee.
     */
    public function calculateTotalAmount(): void
    {
        if ($this->amount === null) {
            $this->total_amount = null;

            return;
        }

        $this->total_amount = $this->amount->plus($this->fee ?? Money::zero($this->amount->currency()));
    }
}
